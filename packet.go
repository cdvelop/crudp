package crudp

import (
	"context"

	. "github.com/cdvelop/tinystring"
)

// Packet represents both requests and responses of the protocol
type Packet struct {
	Action    byte     // action: 'c', 'r', 'u', 'd'
	HandlerID uint8    // shared index within the registration slice
	ReqID     string   // unique ID generated by the client (e.g., UnixID)
	Data      [][]byte // slice of encoded data, each []byte is a structure
}

// BatchRequest is what is sent in the POST /sync
type BatchRequest struct {
	Packets []Packet
}

// BatchResponse is what is received by SSE
type BatchResponse struct {
	Results []PacketResult
}

type PacketResult struct {
	ReqID   string // correlation with the original request
	Success bool   // true/false
	Message string // error or success message
	Data    []byte // encoded result (if applicable)
}

// EncodePacket encodes a packet for a known handler using this CrudP's TinyBin instance
func (cp *CrudP) EncodePacket(action byte, handlerID uint8, reqID string, data ...any) ([]byte, error) {
	encoded := make([][]byte, 0, len(data))
	for _, item := range data {
		bytes, err := cp.tinyBin.Encode(item)
		if err != nil {
			return nil, err
		}
		encoded = append(encoded, bytes)
	}

	packet := Packet{
		Action:    action,
		HandlerID: handlerID,
		ReqID:     reqID,
		Data:      encoded,
	}

	return cp.tinyBin.Encode(packet)
}

// DecodePacket decodes a packet using this CrudP's TinyBin instance
func (cp *CrudP) DecodePacket(data []byte, packet *Packet) error {
	return cp.tinyBin.Decode(data, packet)
}

// DecodeData decodes the packet data using this CrudP's TinyBin instance
func (cp *CrudP) DecodeData(packet *Packet, index int, target any) error {
	if index >= len(packet.Data) {
		return Errf("index out of range")
	}
	return cp.tinyBin.Decode(packet.Data[index], target)
}

// ProcessBatch automatically processes a batch of packets and returns batch results
func (cp *CrudP) ProcessBatch(ctx context.Context, requestBytes []byte) ([]byte, error) {
	var batchReq BatchRequest
	if err := cp.tinyBin.Decode(requestBytes, &batchReq); err != nil {
		return cp.createErrorBatchResponse("decode_error", err)
	}

	results := make([]PacketResult, 0, len(batchReq.Packets))

	for _, packet := range batchReq.Packets {
		result, err := cp.processSinglePacket(ctx, &packet)
		results = append(results, result)
		if err != nil {
			// Continue processing other packets even if one fails
			continue
		}
	}

	batchResp := BatchResponse{
		Results: results,
	}

	return cp.tinyBin.Encode(batchResp)
}

// processSinglePacket processes a single packet and returns a PacketResult
func (cp *CrudP) processSinglePacket(ctx context.Context, packet *Packet) (PacketResult, error) {
	// Decode packet data to concrete types using the handler's type information
	decodedData, err := cp.decodeWithKnownType(packet, packet.HandlerID)
	if err != nil {
		return PacketResult{
			ReqID:   packet.ReqID,
			Success: false,
			Message: err.Error(),
		}, err
	}

	responses, err := cp.callHandler(ctx, packet.HandlerID, packet.Action, decodedData...)
	if err != nil {
		return PacketResult{
			ReqID:   packet.ReqID,
			Success: false,
			Message: err.Error(),
		}, err
	}

	// Process responses for routing and data
	var responseData []byte
	for _, resp := range responses {
		if response, ok := resp.(Response); ok {
			data, broadcast, respErr := response.Response()
			if respErr != nil {
				return PacketResult{
					ReqID:   packet.ReqID,
					Success: false,
					Message: respErr.Error(),
				}, respErr
			}
			// Handle SSE routing based on broadcast
			cp.routeToSSE(data, broadcast, packet.HandlerID)

			// Use the first response data for the direct response
			if responseData == nil {
				if bytes, ok := data.([]byte); ok {
					responseData = bytes
				} else {
					responseData, err = cp.tinyBin.Encode(data)
					if err != nil {
						return PacketResult{
							ReqID:   packet.ReqID,
							Success: false,
							Message: err.Error(),
						}, err
					}
				}
			}
		} else {
			// Fallback for non-Response items
			if responseData == nil {
				if bytes, ok := resp.([]byte); ok {
					responseData = bytes
				} else {
					responseData, err = cp.tinyBin.Encode(resp)
					if err != nil {
						return PacketResult{
							ReqID:   packet.ReqID,
							Success: false,
							Message: err.Error(),
						}, err
					}
				}
			}
		}
	}

	return PacketResult{
		ReqID:   packet.ReqID,
		Success: true,
		Message: "success",
		Data:    responseData,
	}, nil
}

// createErrorBatchResponse creates a batch response with a single error result
func (cp *CrudP) createErrorBatchResponse(message string, err error) ([]byte, error) {
	batchResp := BatchResponse{
		Results: []PacketResult{
			{
				ReqID:   "",
				Success: false,
				Message: Fmt(":%s: %v", message, err),
			},
		},
	}
	return cp.tinyBin.Encode(batchResp)
}

// ProcessPacket processes a single packet (for backward compatibility)
// Internally wraps in a batch and processes
func (cp *CrudP) ProcessPacket(ctx context.Context, requestBytes []byte) ([]byte, error) {
	var packet Packet
	if err := cp.DecodePacket(requestBytes, &packet); err != nil {
		return nil, err
	}

	batchReq := BatchRequest{Packets: []Packet{packet}}
	batchBytes, err := cp.tinyBin.Encode(batchReq)
	if err != nil {
		return nil, err
	}

	batchRespBytes, err := cp.ProcessBatch(ctx, batchBytes)
	if err != nil {
		return nil, err
	}

	var batchResp BatchResponse
	if err := cp.tinyBin.Decode(batchRespBytes, &batchResp); err != nil {
		return nil, err
	}

	if len(batchResp.Results) != 1 {
		return nil, Errf("unexpected batch results")
	}

	result := batchResp.Results[0]

	responsePacket := Packet{
		Action:    packet.Action,
		HandlerID: packet.HandlerID,
		ReqID:     result.ReqID,
		Data:      [][]byte{result.Data},
	}

	return cp.tinyBin.Encode(responsePacket)
}
